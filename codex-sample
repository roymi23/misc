public class FactorialRecursion {

    // Recursive method to calculate factorial
    public static long factorial(int n) {
        if (n < 0) {
            throw new IllegalArgumentException("Factorial is not defined for negative numbers.");
        }
        if (n == 0 || n == 1) {
            return 1;
        }
        return n * factorial(n - 1);
    }

    // Main method to test the recursion
    public static void main(String[] args) {
        int number = 5; // Change this to test other values
        long result = factorial(number);
        System.out.println("Factorial of " + number + " is: " + result);
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


package com.example.railroad;

import java.util.Scanner;

public class BinaryGapFinder {
    public static int findBinaryGap(int n) {
        String binary = Integer.toBinaryString(n);
        System.out.println("Binary reprn. of number " + n + " is " + binary);
        int maxGap = 0;
        int currentGap = 0;
        boolean counting = false;

        for (char bit : binary.toCharArray()) {
            if (bit == '1') {
                if (counting) {
                    maxGap = Math.max(maxGap, currentGap);
                }
                counting = true;
                currentGap = 0;
            } else if (counting) {
                currentGap++;
            }
        }

        return maxGap;
    }

    public static void main(String[] args) {
        int number = 529;
        Scanner scanner = new Scanner(System.in);
        String ans = "Y";
        while (ans.equalsIgnoreCase("y")) {
            System.out.println("Please enter your number..");
            number = scanner.nextInt();
            System.out.println("Binary gap of " + number + " is: " + findBinaryGap(number));
            System.out.println("Do you want to continue?");
            ans = scanner.nextLine();
        }

    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

package com.practise.dsa;

public class FibonacciRecursion {

    // Recursive method to calculate nth Fibonacci number
    public static int fibonacci(int n) {
        if (n < 0) {
            throw new IllegalArgumentException("Index cannot be negative.");
        }
        if (n == 0) return 0;
        if (n == 1) return 1;
        return fibonacci(n - 1) + fibonacci(n - 2);
    }

    // Method to print the Fibonacci sequence up to n terms
    public static void printFibonacciSequence(int terms) {
        System.out.println("Fibonacci sequence up to " + terms + " terms:");
        for (int i = 0; i < terms; i++) {
            System.out.print(fibonacci(i) + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int terms = 10; // Change this to generate more terms
        printFibonacciSequence(terms);
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


package com.practise.dsa;

import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class IPAddressValidation {

    // Regex for digit from 0 to 255.
    private static  String zeroTo255
            = "(\\d{1,2}|(0|1)\\"
            + "d{2}|2[0-4]\\d|25[0-5])";

    // Regex for a digit from 0 to 255 and
    // followed by a dot, repeat 4 times.
    // this is the regex to validate an IP address.
    public static String regex
            = zeroTo255 + "\\."
            + zeroTo255 + "\\."
            + zeroTo255 + "\\."
            + zeroTo255;

    public static void main(String[] args) {

//        Scanner sC = new Scanner(System.in);
//
//        System.out.println("Please enter your Ip Address.");
//
//        String input = sC.nextLine();
//
//        System.out.println("Given string: " + input + " is a valid IPAddress? " + isValidIpAddress(input));

        Scanner in = new Scanner(System.in);
        System.out.println("Please enter your Ip Address.");
        while(in.hasNext()){
            String IP = in.next();
            System.out.println(IP.matches(regex));
        }
    }

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

package com.practise.dsa;

import java.util.HashMap;

class LRUCache {
    private class Node {
        int key, value;
        Node prev, next;
        Node(int k, int v) { key = k; value = v; }
    }

    private final int capacity;
    private final HashMap<Integer, Node> map;
    private final Node head, tail;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new HashMap<>();
        head = new Node(0, 0); // dummy head
        tail = new Node(0, 0); // dummy tail
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        if (!map.containsKey(key)) return -1;
        Node node = map.get(key);
        remove(node);
        insertToFront(node);
        return node.value;
    }

    public void put(int key, int value) {
        if (map.containsKey(key)) {
            remove(map.get(key));
        }
        if (map.size() == capacity) {
            remove(tail.prev); // remove LRU
        }
        insertToFront(new Node(key, value));
    }

    private void remove(Node node) {
        map.remove(node.key);
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private void insertToFront(Node node) {
        map.put(node.key, node);
        node.next = head.next;
        node.prev = head;
        head.next.prev = node;
        head.next = node;
    }

    // For testing
    public static void main(String[] args) {
        LRUCache cache = new LRUCache(2);
        cache.put(1, 1); // cache = {1=1}
        cache.put(2, 2); // cache = {1=1, 2=2}
        System.out.println(cache.get(1)); // returns 1
        cache.put(3, 3); // evicts key 2, cache = {1=1, 3=3}
        System.out.println(cache.get(2)); // returns -1
        cache.put(4, 4); // evicts key 1, cache = {4=4, 3=3}
        System.out.println(cache.get(1)); // returns -1
        System.out.println(cache.get(3)); // returns 3
        System.out.println(cache.get(4)); // returns 4
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

package com.practise.dsa;

import java.sql.SQLOutput;
import java.util.Scanner;

public class MaxSubArray {

    public static void main(String[] args) {

        Scanner sC = new Scanner(System.in);
        System.out.println("Please enter your numbers separated by commas..");
        String inputString = sC.nextLine();
        String[] tokens = inputString.split(",");
        int[] nums = new int[tokens.length];
        for (int i = 0; i < tokens.length; i++) {
            try {
                nums[i] = Integer.parseInt(tokens[i]);
            } catch (NumberFormatException e) {
                //
            }
        }

        System.out.println("Max subarray: " + maximumSubArray(nums));

    }

    private static int maximumSubArray(int[] nums) {

        int maxEndingHere = 0;
        int maxSumSoFar = 0;
        for (int i = 0; i < nums.length; i++) {

            maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);
            maxSumSoFar = Math.max(maxSumSoFar, maxEndingHere);

        }
        return maxSumSoFar;
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


package com.practise.dsa;

public class PalindromeRecursion {

    // Recursive method to check if a string is a palindrome
    public static boolean isPalindrome(String str, int left, int right) {
        if (left >= right) {
            return true; // Base case: all characters matched
        }
        if (str.charAt(left) != str.charAt(right)) {
            return false; // Mismatch found
        }
        return isPalindrome(str, left + 1, right - 1); // Move inward
    }

    // Wrapper method for cleaner usage
    public static boolean isPalindrome(String str) {
        if (str == null) return false;
        str = str.replaceAll("[^a-zA-Z0-9]", "").toLowerCase(); // Normalize input
        System.out.println("Normalize string = " + str);
        return isPalindrome(str, 0, str.length() - 1);
    }

    public static void main(String[] args) {
        String input = "RaceCar"; // Try other examples like "A man, a plan, a canal: Panama"
        if (isPalindrome(input)) {
            System.out.println("\"" + input + "\" is a palindrome.");
        } else {
            System.out.println("\"" + input + "\" is not a palindrome.");
        }
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


package com.practise.dsa;

import org.springframework.util.StringUtils;

public class PalindromeCheckStringReverse {

    public static void main(String[] args) {
        String input = "A man, a plan, a canal: Panama";
        System.out.println(input + " is palindrome? " + isPalindrome(input));
    }

    private static boolean isPalindrome(String input) {
        input = input.replaceAll("[^a-zA-Z0-9]", "");
        String reversedString = new StringBuilder(input).reverse().toString();
        return input.equalsIgnoreCase(reversedString);
    }
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


package com.practise.dsa;

import java.io.*;
import java.util.*;
import java.util.stream.IntStream;
import java.lang.reflect.Method;

public class PrimeCheck {

    public static void main(String[] args) {
        InputStream in = System.in;
        BufferedReader br=new BufferedReader(new InputStreamReader(in));
        try {
            int n1=Integer.parseInt(br.readLine());
            int n2=Integer.parseInt(br.readLine());
            int n3=Integer.parseInt(br.readLine());
            int n4=Integer.parseInt(br.readLine());
            int n5=Integer.parseInt(br.readLine());
            Prime.checkPrime(n1);
            Prime.checkPrime(n1,n2);
            Prime.checkPrime(n1,n2,n3);
            Prime.checkPrime(n1,n2,n3,n4,n5);

            br.close();
        }
        catch(Exception e) {

        }



        Method[] methods=Prime.class.getDeclaredMethods();
        Set<String> set=new HashSet<>();
        boolean overload=false;
        for(int i=0;i<methods.length;i++)
        {
            if(set.contains(methods[i].getName()))
            {
                overload=true;
                break;
            }
            set.add(methods[i].getName());

        }
        try {
            if(overload)
            {
                throw new Exception("Overloading not allowed");
            }
        }
        catch(Exception e)
        {
            System.out.println(e);
        }
    }


    static class Prime {

        static void checkPrime(int...integers) {

            IntStream.of(integers).forEach(n-> {
                int factors = 0;
                for (int i=0; i<=n;i++){
                    if (n%i == 0)
                        factors++;
                }
                if (factors > 2) {
                    System.out.print(n);
                }
                System.out.print("\n");
            });
        }
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


package com.ford.gdia.hvbd.util;

import java.util.Scanner;
import java.util.regex.Matcher;

public class PasswordValidator {

    public static void main(String[] args) {
        String password = "Test@1234";
        String response = "";

        while(response.equalsIgnoreCase("yes") || response.isEmpty()) {
            // Prompt the user for a password to validate
            String input = "Please enter a password to validate: ";
            clearConsole();
            String confirmation = "Do you want to validate another password? (yes/no)";
            System.out.println(input);
            Scanner scanner = new Scanner(System.in);
            password = scanner.nextLine();

            if (isValidPassword(password)) {
                System.out.println("Password is valid.");
            } else {
                System.out.println("Password is invalid.");
            }

            System.out.println(confirmation);
            response = scanner.nextLine().trim().toLowerCase();
        }

    }

    private static void clearConsole() {
        System.out.print("\033[H\033[2J"); // ANSI escape code to clear console
        System.out.flush(); // Flush the output buffer
    }

    private static boolean isValidPassword(String password) {

        String regexPattern = "^(?=.*[0-9])" +         // at least one digit
                              "(?=.*[a-z])" +         // at least one lowercase letter
                              "(?=.*[A-Z])" +         // at least one uppercase letter
                              "(?=.*[@#$%^&+=])" +    // at least one special character
                              "(?=\\S+$)" +           // no whitespace
                              ".{8,}$";
        // at least 8 characters
        Matcher matcher = java.util.regex.Pattern.compile(regexPattern).matcher(password);
        return matcher.matches();

    }

}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

package com.ford.gdia.hvbd.util;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class IntStreamStatistics {

    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 10};

        // Calculate Mean (Average)
        double mean = IntStream.of(numbers)
                .average()
                .orElse(Double.NaN); // Handle empty stream

        System.out.println("Mean: " + mean);

        // Calculate Median
        List<Integer> sortedNumbers = IntStream.of(numbers)
                .sorted()
                .boxed() // Convert to Stream<Integer>
                .collect(Collectors.toList());

        double median;
        int size = sortedNumbers.size();
        if (size % 2 == 0) {
            // Even number of elements, average of two middle elements
            median = (sortedNumbers.get(size / 2 - 1) + sortedNumbers.get(size / 2)) / 2.0;
        } else {
            // Odd number of elements, middle element
            median = sortedNumbers.get(size / 2);
        }
        System.out.println("Median: " + median);

        // Calculate Mode
        Map<Integer, Long> frequencyMap = IntStream.of(numbers)
                .boxed()
                .collect(Collectors.groupingBy(i -> i, Collectors.counting()));

        long maxFrequency = frequencyMap.values().stream()
                .mapToLong(Long::longValue)
                .max()
                .orElse(0); // Handle empty stream

        List<Integer> modes = frequencyMap.entrySet().stream()
                .filter(entry -> entry.getValue() == maxFrequency)
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());
        System.out.println("Mode(s): " + modes);
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

package com.ford.gdia.hvbd.util;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

public class TwoSum {

    public static void main(String[] args) {
        int[] numbers = {2, 7, 11, 15};
        int target = 9;
        int[] result = twoSum(numbers, target);
        if (result != null) {
            System.out.println("Indices: " + result[0] + ", " + result[1]);
        } else {
            System.out.println("No two sum solution found.");
        }
    }

    private static int[] twoSum(int[] numbers, int target) {
        if (numbers == null || numbers.length < 2) {
            return null; // Not
        }
        Map<Integer, Integer> map = new HashMap<>();
        for (int i=0; i<numbers.length;i++) {
            int complement = target - numbers[i];
            if (map.containsKey(complement)){
                return new int[]{complement, numbers[i]};
            }
            map.put(numbers[i], i);
        }
        return null; // No two sum solution found
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


package com.example.railroad;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class EmailValidator {

    // Define the regex pattern for a valid email
    private static final String EMAIL_REGEX =
            "^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,6}$";

    // Compile the regex into a Pattern
    private static final Pattern EMAIL_PATTERN = Pattern.compile(EMAIL_REGEX);

    // Method to validate email
    public static boolean isValidEmail(String email) {
        if (email == null) return false;
        Matcher matcher = EMAIL_PATTERN.matcher(email);
        return matcher.matches();
    }

    // Test the validator
    public static void main(String[] args) {
        String[] testEmails = {
                "user@example.com",
                "user.name+tag+sorting@example.co.uk",
                "user@subdomain.example.com",
                "invalid-email@.com",
                "another.invalid@com",
                "missing@domain"
        };

        for (String email : testEmails) {
            System.out.printf("Email: %-35s Valid: %b%n", email, isValidEmail(email));
        }
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

package com.example.railroad;

import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

/**
 * Implement the mean, median, mode and range methods of the Calculator class in Java 8 Functional
 * style with the minimum code necessary to pass the tests.
 */
class FunctionalTest {

    @Test
    void range() {
        assertEquals(14, calculator.range(3, 17, 15, 11, 9));
    }

    @Test
    void mean() {
        assertEquals(12.5, calculator.mean(13, 19, null, 14, 16, 5, 8), 0);
    }

    @Test
    void median() {
        assertEquals(6, calculator.median(7, 11, 6, 2, 5), 0);
        assertEquals(13.5, calculator.median(13, 18, 14, 16, 5, 8), 0);
    }

    @Test
    void mode() {
        assertArrayEquals(new int[]{3}, calculator.mode(5, 2, 3, 6, 4, 1, 3));
        assertArrayEquals(new int[]{3, 5}, calculator.mode(4, 5, 3, 1, 3, 2, 5, 6));
        assertArrayEquals(new int[]{5}, calculator.mode(4, 5, 5, 3, 1, 3, 2, 5, 6));
        assertArrayEquals(new int[]{1, 2, 3, 4, 5}, calculator.mode(1, 3, 2, 4, 5));
    }

    private class Calculator {

        /**
         * range: the difference between min and max values
         */
        int range(int... input) {

            return 0;
        }

        /**
         *  mean: the average of the numbers
         */
        double mean(Integer... input) {
            Integer[] integers = input;
            final Integer sum = Arrays.asList(integers).stream().reduce(0, (a, b) -> a + b);
            final double average = sum / integers.length;
            return average;
        }

        /**
         * median: the middle number in a sorted list
         * ...if there are two middle values, return the average of the two
         */
        double median(int... input) {
return 0;
        }


        /**
         *  mode: the most frequently occurring number
         */
        int[] mode(int... input) {
            int[] numbers = input;
//            List.of(numbers).stream().sorted().collect(Collectors.groupingBy(),Collectors.counting());
            return null;
        }
    }

    private final Calculator calculator = new Calculator();
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


package com.example.railroad;

import java.util.HashSet;

public class MissingPositiveFinder {
    public static int findMissingPositive(int[] nums) {
        HashSet<Integer> set = new HashSet<>();

        // Add all positive numbers to the set
        for (int num : nums) {
            if (num > 0) {
                set.add(num);
            }
        }

        // Start checking from 1 upwards
        int missing = 1;
        while (set.contains(missing)) {
            missing++;
        }

        return missing;
    }

    public static void main(String[] args) {
        int[] nums = {3, 4, -1, 1};
        int missing = findMissingPositive(nums);
        System.out.println("The smallest missing positive integer is: " + missing);
    }
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

package com.example.railroad;

import java.util.ArrayList;
import java.util.List;

public class PrimeFactors {

    public static List<Integer> findPrimeFactors(int number) {
        List<Integer> primeFactors = new ArrayList<>();

        // Check for divisibility by 2
        while (number % 2 == 0) {
            primeFactors.add(2);
            number /= 2;
        }

        System.out.println("1. Number is now " + number);

        // Check for divisibility by odd numbers starting from 3
        for (int i = 3; i <= Math.sqrt(number); i += 2) {
            System.out.println("i = " + i);
            while (number % i == 0) {
                primeFactors.add(i);
                System.out.println("Added prime factor: " + i);
                number /= i;
            }
        }

        System.out.println("2. Number is now " + number);

        // If number is prime, add it to the list
        if (number > 2) {
            primeFactors.add(number);
        }

        return primeFactors;
    }

    public static void main(String[] args) {
        int number = 54;
        System.out.println(Math.sqrt(number));
        List<Integer> factors = findPrimeFactors(number);
        System.out.println("Prime factors of " + number + ": " + factors);
    }
}




